{"name":"Validator","tagline":"A plain-as-vanilla validating package written for Python.","body":"[![Build Status](https://drone.io/github.com/wilhelm-murdoch/Validator/status.png)](https://drone.io/github.com/wilhelm-murdoch/Validator/latest) [![Code Health](https://landscape.io/github/wilhelm-murdoch/Validator/master/landscape.png)](https://landscape.io/github/wilhelm-murdoch/Validator/master)\r\n\r\n### Validator\r\n===\r\n\r\nI wrote this because I could not find a validation for Python that didn't require some crazy dependencies, or wasn't plain simple to work with. This does precisely what the title suggests; it makes it easier to manage input validation in Python.\r\n\r\nThere are a handful of other validation libraries out there, but they are all either dated or require you to work your head around some strange syntax. This is the package you want to use when you don't want waste precious time thinking about how the validator should work; it's all in plain English.\r\n\r\nSay you want to validator an online form. A form is just a `collection` of `fields`. These `fields` must follow certain `rules`. This is the naming convention used throughout the library.\r\n\r\n## Installation\r\n\r\n### From Source\r\n\r\nIf you plan on forking and doing some local development, follow these steps.\r\n\r\n    $: git clone git@github.com:wilhelm-murdoch/validator.git\r\n    $: cd validator\r\n    $: python setup.py install\r\n\r\nAlternatively, you can use the following make targets for local development:\r\n\r\n1. `make install` installs validator locally in development mode.\r\n2. `make uninstall` removes validator locally\r\n3. `make test` runs the unit test suite\r\n4. `make clean` removes any garbage files that usage and installation generates\r\n\r\n### Using Pip\r\n\r\nIf you have pip installed, you should be able to run the following command:\r\n\r\n    $: pip install validator\r\n    \r\nOr,\r\n\r\n    $: pip install git+ssh://git@github.com/wilhelm-murdoch/validator.git\r\n\r\nOr, you can add the following line to your `requirements.txt` file:\r\n\r\n    -e git+git://github.com/wilhelm-murdoch/validator.git#egg=validator\r\n\r\n## Examples\r\n\r\nThe following example shows how you would validate a standard user account with `username`, `email` and `password` fields using some built-in validation rules and their default error messages:\r\n\r\n```python\r\nfrom validator import collection, field, rules\r\n\r\nform = collection.Collection().append([\r\n    field.Field('username', 'wilhelm').append([\r\n          rules.IsRequired()\r\n        , rules.IsAlphaNumeric()\r\n        , rules.IsLengthBetween(3, 10)\r\n    ]),\r\n    field.Field('email', 'wilhelm@gmail.com').append([\r\n          rules.IsRequired()\r\n        , rules.IsEmail()\r\n    ]),\r\n    field.Field('password', 'root').append([\r\n          rules.IsRequired()\r\n        , rules.IsLengthBetween(2, 10)\r\n    ]),\r\n    field.Field('password-confirm', 'root').append([\r\n        rules.Matches('root')\r\n    ])\r\n])\r\n```\r\n\r\nNow, to run the validator, just do:\r\n\r\n```python\r\n>>> print form.run()\r\nTrue\r\n```\r\n\r\nBy default, method `collection.run` will return a boolean value representing the result of the validation. If you want more detailed information, you have a few options.\r\n\r\nOnce you've run the validation process. You can do the following:\r\n\r\n```python\r\n>>> print form.results()\r\n[{\r\n    'field': 'username',\r\n    'passed': True,\r\n    'value': 'wilhelm',\r\n    'errors': None\r\n}, {\r\n    'field': 'email',\r\n    'passed': True,\r\n    'value': 'wilhelm.murdoch@gmail.com',\r\n    'errors': None\r\n}, {\r\n    'field': 'password',\r\n    'passed': True,\r\n    'value': 'root',\r\n    'errors': None\r\n}, {\r\n    'field': 'password-confirm',\r\n    'passed': True,\r\n    'value': 'root',\r\n    'errors': None\r\n}]\r\n```\r\n\r\nOr, you can just do:\r\n\r\n```python\r\n>>> print form.run(True)\r\n... same output as above ...\r\n```\r\n\r\nIf any fields don't pass validation, the results will provide a list of relevent errors associated with the field in question. For example:\r\n\r\n```python\r\n>>> print form.results()\r\n[\r\n    ...\r\n    {\r\n        'field': 'email',\r\n        'passed': False,\r\n        'errors': [\r\n            'Length is too short',\r\n            'Is not a valid email address',\r\n            'Some other error'\r\n        ]\r\n        'value': 'bar'\r\n    }\r\n    ...\r\n]\r\n```\r\n\r\nYou can also specify a custom error message for your validation rule. For instance:\r\n\r\n```python\r\nfrom validator import collection, field, rules\r\n\r\nform = collection.Collection().append([\r\n    field.Field('username', 'wilhelm').append([\r\n          rules.IsRequired(error='heh.')\r\n        , rules.IsAlphaNumeric(error='lolwut?')\r\n        , rules.IsLengthBetween(3, 10, error='It is either too long or too short, man.')\r\n    ]),\r\n])\r\n```\r\n\r\nIf this form generated errors, you'd get the following output:\r\n\r\n```python\r\n>>> print form.results()\r\n[\r\n    ...\r\n    {\r\n        'field': 'username',\r\n        'passed': False,\r\n        'errors': [\r\n            'heh.',\r\n            'lolwut?',\r\n            'It is either too long or too short, man.'\r\n        ]\r\n        'value': 'wilhelm'\r\n    }\r\n    ...\r\n]\r\n```\r\n\r\nIf you want to return a JSON representation of your form, you can do the following:\r\n\r\n```python\r\n>>> print form.form()\r\n{\r\n    'username': 'wilhelm',\r\n    'password': 'root',\r\n    'password-confirm': 'root',\r\n    'email': 'wilhelm@gmail.com'\r\n}\r\n```\r\n\r\n## Extending\r\n\r\nWriting your own rules is quite simple. You just have to make sure your own rules derive from class `validator.rule.Rule`. \r\n\r\nHere's a simple example:\r\n\r\n```python\r\nfrom validator import rule\r\n\r\nclass IsFoo(rule.Rule):\r\n    def run(self, field_value):\r\n        if field_value is 'foo':\r\n            return True\r\n        return False\r\n```            \r\n\r\nThere you go, it's as easy as that. Now, let's test it out:\r\n\r\n```python\r\nfrom validator import collection, field\r\nfrom some.path.in.your.app import IsFoo\r\n\r\nresults = collection.Collection().append([\r\n    field.Field('field_name', 'foo').append([\r\n        IsFoo()\r\n    ])\r\n]).run()\r\n```\r\n\r\nThe validator will now check if `field_name` equals `foo`. The result of the validation is stored in `results`:\r\n\r\n```python\r\n>>> print results\r\nTrue\r\n```    \r\n    \r\nOf course, setting `return_collated_results` to `True` in `Collection.run()` will return some more useful information:\r\n\r\n```python\r\n>>> print results\r\n[{\r\n    'field': 'field_name',\r\n    'passed': True,\r\n    'value': 'foo'\r\n}]\r\n```\r\n\r\n## Unit Tests Usage\r\n\r\nTests have been made with the use of Nose (https://github.com/nose-devs/nose). Just navigate to the testing directory of choice run the `make test` command to run the entire suite.\r\n\r\n## Questions\r\n\r\nThe best place to ask questions would be in the `Issues` section or on Twitter [@wilhelm](http://twitter.com/wilhelm)\r\n\r\n## Contributions\r\n\r\nA helping hand is always welcome. The current build includes a fair amount of built-in validation rules, but it could always use a few more. If you find what's available to be a bit lacking, feel free to fork and submit a pull request.\r\n\r\nAll I ask is the following:\r\n\r\n* Consistency. Try your best to follow the same coding style in use.\r\n* Documentation. Document all the things!\r\n* Tests. Please write functional and unit tests where and when possible.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}